; our abi for 16bit
; ax,bx,cx,dx,dp - можно менять, не рассчитываем, что там лежит то, что нам надо
; si, di - должны не меняться от вызовов макросов и функций
; с остальными вроде очев
[BITS 16]           ; Указание ассемблеру, что код будет выполняться в 16-битном режиме.
jmp _start

; копируем участок памяти,
; начинающийся с %1:0
; в %2:0 длинной %3 байт
%macro copy 3
    push di
    push si

; mov out ds:si (ds*16+si)
    mov ax, %1
    mov ds, ax
    xor si, si
; в сегментные регистры нельзя писать
; поэтому пузырим черех другие
    mov ax, %2
    mov es, ax
    xor di, di
; mov to  es:di (es*16+di)

    mov cx, %3
    rep movsb

    pop si
    pop di
%endmacro

%macro read_chs 2; %1 - номер цилиндра, %2 - СЕГМЕНТ, того куда пишем (смещение=0)
    mov ax, %1      ; номер цилиндра
    mov ch, al      ; номер цилиндра
    mov ah, 0x2     ; номер функции
    mov al, 18      ; количесто секторов
    mov cl, 1       ; номер первого цилиндра
    mov bx, %2
    mov es, bx      ; адрес того, куда пишем (0xadres:0)
    xor bx, bx      ; --------------------------------^-
    xor dh, dh      ; номер головки
    int 0x13        ; номер прерывания
    mov bx, %2
    add bx, SIZE_9KB; 9 килобайт
    mov es, bx      ; куда снова пишем
    inc dh          ; меняем головку
    int 0x13        ; номер прерывания
%endmacro

%macro load_chs 2; %1 - номер цилиндра, %2 - СЕГМЕНТ, того куда копируем (смещение=0)
    read_chs %1, BUFF
    copy BUFF, %2, SIZE_18KB
%endmacro

print_string:
    mov ah, 0x0E    ; Устанавливаем режим BIOS для вывода символов в текстовом режиме (INT 0x10).
.next_char:
    lodsb           ; Загружаем следующий байт (символ) из [SI] в AL.
    cmp al, 0       ; Сравниваем AL с нулем (нулевой байт означает конец строки).
    je done         ; Если AL равен 0, перейти на метку done.
    int 0x10        ; Вызов прерывания 0x10 для вывода символа на экран.
    jmp .next_char  ; Переход к обработке следующего символа.
done:               ; Метка окончания вывода строки.
    ret             ; Возврат из процедуры.

_start:

    mov sp, 0x1000        ; Устанавливаем указатель стека (SP) в значение 1000. Задает начальный адрес стека.
    mov ss, sp          ; Устанавливаем сегмент стека (SS) равным 1. Это странно, потому что сегмент стека обычно соответствует значению в SP.
    xor sp, sp          ; Обнуляем указатель стека (SP).

    cli                 ; Отключаем прерывания для безопасности при настройке сегментных регистров.

    mov ax, 0x07c0      ; Загружаем значение 0x07C0 в регистр AX.
    mov ds, ax          ; Устанавливаем сегмент данных (DS) на 0x07C0 (начало загрузочного сектора).


    sti                 ; Включаем прерывания после инициализации сегментов.

    mov si, msg
    call print_string

    mov si, 0x1       ; итератор по цилиндрам
    mov di, START_SEG ;
start_load:
    load_chs si, di
    ;shr di, 4
    add di, SIZE_18KB / 16; танцы с бубном так как di - сегмент
    ;shl di, 4
    inc si
    cmp si, COUNT_CIL
    jg start_load ; if (si > COUNT_CIL) { goto start_load }

    ;jmp 0x7fe0:0x0000+end_copy_vbr  ; Переход на новый адрес 0x7FE0:0, куда был скопирован код.

msg db '  ____   _____              _', 10, 13
    db ' / __ \ / ____|     (*)    | |', 10, 13
    db '| |  | | (___  _ __  _  ___| |__   _____   __', 10, 13
    db '| |  | |\___ \|  _ \| |/ __|  _ \ / _ \ \ / /', 10, 13
    db '| |__| |____) | |_) | | (__| | | |  __/\ V /', 10, 13
    db ' \____/ \____/| .__/|_|\___|_| |_|\___| \_/', 10, 13
    db '              | |', 10, 13
    db '              |_|', 10, 13, 0

START_SEG equ 0x1400  ; СГЕМЕНТ тоого, где начинается OS
COUNT_CIL equ 24      ; (0x80000 - 0x14000) / size_18kb
BUFF      equ 0x100   ; СЕГМЕНТ буфера, НЕ адрес
SIZE_9KB  equ 0x2400
SIZE_18KB equ 0x4800

times 510-($-$$) db 0     ; Добавляем нули, чтобы заполнить до 510 байт (размер загрузочного сектора 512 байт).
dw 0xAA55                 ; Магическое число завершения загрузочного сектора, которое BIOS использует для проверки загрузочного сектора.