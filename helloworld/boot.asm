[BITS 16]           ; Указание ассемблеру, что код будет выполняться в 16-битном режиме.
cli                 ; Отключаем прерывания для безопасности при настройке сегментных регистров.

mov ax, 0x07c0      ; Загружаем значение 0x07C0 в регистр AX.
mov ds, ax          ; Устанавливаем сегмент данных (DS) на 0x07C0 (начало загрузочного сектора).

mov sp, 1           ; Устанавливаем указатель стека (SP) в значение 1. Необычная инициализация, обычно здесь устанавливается верхняя граница стека.
mov ss, sp          ; Устанавливаем сегмент стека (SS) равным 1. Это странно, потому что сегмент стека обычно соответствует значению в SP.
xor sp, sp          ; Обнуляем указатель стека (SP).

sti                 ; Включаем прерывания после инициализации сегментов.

copy_vbr:           ; Метка начала блока кода для копирования вектора начальной загрузки (VBR).
; mov out ds:si (ds*16+si)
    xor si, si      ; Обнуляем регистр SI, устанавливаем его на начало данных по смещению 0.

; mov to  es:di (es*16+di)
    mov di, 0x7fe0  ; Загружаем адрес 0x7FE0 в DI (предполагаемое место для VBR).
    mov es, di      ; Устанавливаем сегмент ES на 0x7FE0, где будет храниться VBR.
    xor di, di      ; Обнуляем регистр DI для копирования с начала сегмента ES.

;0x7fe0:0
; ^ ^ ^
; | | | 
;0x07c0:0

    mov cx, 0x0200  ; Устанавливаем счётчик (CX) на 512 байт для копирования (размер загрузочного сектора).
    rep movsb       ; Копируем 512 байт из DS:SI в ES:DI, автоматически увеличивая SI и DI.

    jmp 0x7fe0:0x0000+end_copy_vbr  ; Переход на новый адрес 0x7FE0:0, куда был скопирован код.

end_copy_vbr:       ; Метка конца копирования VBR.
    mov si, msg     ; Загружаем адрес строки 'Hello, world!' в SI.
    call print_string ; Вызываем процедуру для печати строки.

    jmp $           ; Зацикливаем выполнение программы (бесконечный цикл).

print_string:       ; Начало процедуры печати строки.
    mov ah, 0x0E    ; Устанавливаем режим BIOS для вывода символов в текстовом режиме (INT 0x10).
.next_char:         ; Метка для печати следующего символа.
    lodsb           ; Загружаем следующий байт (символ) из [SI] в AL.
    cmp al, 0       ; Сравниваем AL с нулем (нулевой байт означает конец строки).
    je done         ; Если AL равен 0, перейти на метку done.
    int 0x10        ; Вызов прерывания 0x10 для вывода символа на экран.
    jmp .next_char  ; Переход к обработке следующего символа.

done:               ; Метка окончания вывода строки.
    ret             ; Возврат из процедуры.

msg db 'Hello, world!', 0 ; Строка для вывода с завершающим нулем.

times 510-($-$$) db 0     ; Добавляем нули, чтобы заполнить до 510 байт (размер загрузочного сектора 512 байт).
dw 0xAA55                 ; Магическое число завершения загрузочного сектора, которое BIOS использует для проверки загрузочного сектора.
